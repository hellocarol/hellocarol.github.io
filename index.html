<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="node js koa vue react springmvc mongodb mysql jquery bootstrap"><meta name="keywords" content=""><meta name="author" content="cici,undefined"><meta name="copyright" content="cici"><title>cici的个人小站 | hellocici</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.4.3"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  localSearch: undefined
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">cici</div><div class="author-info__description text-center">node js koa vue react springmvc mongodb mysql jquery bootstrap</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">4</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div></div></div><nav class="no-bg" id="nav" style="background-image: url(true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">hellocici</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">hellocici</div><div id="site-sub-title">cici的个人小站</div><div id="site-social-icons"> <a class="social-icon" href="https://github.com/hellocarol" target="_blank"><i class="fa fa-github"></i></a><a class="social-icon" href="https://weibo.com/u/5209982775" target="_blank"><i class="fa fa-weibo"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item"><a class="article-title" href="/2018/07/25/ubuntu环境中使用geth搭建私有网络/">ubuntu环境中使用geth搭建私有网络test</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-25</time><div class="content"><p>相对于图形化操作界面的以太坊客户端mist，基于Go语言开发的geth始终跑在终端里。它提供了一个交互式命令控制台，控制台中包含了以太坊的各种功能。<br>下面介绍一下如何在ubuntu环境中通过geth搭建私有网络。</p>
<h4 id="1-创建运行文件夹"><a href="#1-创建运行文件夹" class="headerlink" title="1.创建运行文件夹"></a>1.创建运行文件夹</h4><h4 id="2-在文件夹下创建json文件"><a href="#2-在文件夹下创建json文件" class="headerlink" title="2.在文件夹下创建json文件"></a>2.在文件夹下创建json文件</h4><p>文件中输入：</p>
<!--
{

  "config": {

        "chainId": 10,
        "homesteadBlock": 0,
        "eip155Block": 0,
        "eip158Block": 0
    },
  "alloc"      : {},

  "coinbase"   : "0x0000000000000000000000000000000000000000",

  "difficulty" : "0x02000000",

  "extraData"  : "",

  "gasLimit"   : "0x2fefd8",

  "nonce"      : "0x0000000000000042",

  "mixhash"    : "0x0000000000000000000000000000000000000000000000000000000000000000",

  "parentHash" : "0x0000000000000000000000000000000000000000000000000000000000000000",

  "timestamp"  : "0x00"
}//这个是错误的，后面会各种报错
 -->
<pre><code>```{
   &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;,

   &quot;config&quot;: {
          &quot;homesteadBlock&quot;: 5
    },

   &quot;difficulty&quot;: &quot;0x20000&quot;,

   &quot;extraData&quot;: &quot;0x&quot;,

   &quot;gasLimit&quot;: &quot;0x2FEFD8&quot;,

   &quot;mixhash&quot;: &quot;0x00000000000000000000000000000000000000647572616c65787365646c6578&quot;,

   &quot;nonce&quot;: &quot;0x0&quot;,

   &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,

   &quot;timestamp&quot;: &quot;0x00&quot;,

   &quot;alloc&quot;: {
          &quot;dbdbdb2cbd23b783741e8d7fcf51e459b497e4a6&quot;:
          {
              &quot;balance&quot;:&quot;100000000000000000000000000000&quot;
          }
   }
}```
</code></pre><!--这个是对的-->
<p>若是输入不当会报错：invalid genesis file: json: cannot unmarshal hex string without 0x prefix into Go struct field Genesis.extraData of type hexutil.Bytes 等</p>
<p><strong>解释一下各个参数的作用：</strong></p>
<ul>
<li><p>mixhash    ：与nonce配合用于挖矿，由上一个区块的一部分生成的hash。注意他和nonce的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。.</p>
</li>
<li><p>nonce：nonce就是一个64位随机数，用于挖矿，注意他和mixhash的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。</p>
</li>
<li><p>difficulty：设置当前区块的难度，如果难度过大，cpu挖矿就很难，这里设置较小难度</p>
</li>
<li><p>alloc：用来预置账号以及账号的以太币数量，因为私有链挖矿比较容易，所以我们不需要预置有币的账号，需要的时候自己创建即可以。</p>
</li>
<li><p>coinbase：矿工的账号，随便填</p>
</li>
<li><p>timestamp：设置创世块的时间戳</p>
</li>
<li><p>parentHash：上一个区块的hash值，因为是创世块，所以这个值是0</p>
</li>
<li><p>extraData：附加信息，随便填，可以填你的个性信息</p>
</li>
<li><p>gasLimit：该值设置对GAS的消耗总量限制，用来限制区块能包含的交易信息总和，因为我们是私有链，所以填最大。</p>
</li>
</ul>
<p><strong>然后进入创建的文件夹执行创造区块命令：</strong></p>
<p><code>geth --datadir &quot;./&quot; init &quot;./genesis.json&quot;</code></p>
<h4 id="3-启动私有链"><a href="#3-启动私有链" class="headerlink" title="3.启动私有链"></a>3.启动私有链</h4><p><strong>进入私有链：</strong><code>geth --datadir &quot;./&quot; --nodiscover console 2&gt;&gt;geth.log</code></p>
<ul>
<li>–datadir 代表文件夹地址</li>
<li>–nodiscover 表示私有链不要让公网上的节点发现</li>
<li>代码 console 2&gt;&gt; geth.log 代表将控制台的一部分输出，输出到文件geth.log上去</li>
</ul>
<p>启动Geth即可以启动以太坊的区块链，为了构建私有链 ，需要在Geth启动时加入一些参数，Geth参数含义如下： </p>
<ul>
<li>identity：区块链的标示，随便填写，用于标示目前网络的名字</li>
<li>init：指定创世块文件的位置，并创建初始块</li>
<li>datadir：设置当前区块链网络数据存放的位置</li>
<li>port：网络监听端口</li>
<li>rpc：启动rpc通信，可以进行智能合约的部署和调试</li>
<li>rpcapi：设置允许连接的rpc的客户端，一般为db,eth,net,web3</li>
<li>networkid：设置当前区块链的网络ID，用于区分不同的网络，是一个数字</li>
<li>console：启动命令行模式，可以在Geth中执行命令</li>
</ul>
<h4 id="4-在私有链上创建用户"><a href="#4-在私有链上创建用户" class="headerlink" title="4.在私有链上创建用户"></a>4.在私有链上创建用户</h4><p>输入命令eth.accounts, 我们会发现返回值为[]</p>
<p>这是因为此时虽然以太坊的私有链已经被创造出来，但还没有任何账户。</p>
<p>输入命令<code>personal.newAccount(“xxx”)</code>, 该命令将创造一个新的用户，XXX为密码</p>
<h4 id="5-输出日志"><a href="#5-输出日志" class="headerlink" title="5.输出日志"></a>5.输出日志</h4><p>输出区块链的Log，打开另一个终端，找到geth.log的所在目录，执行命令 tail -f geth.log 从而持续的输出日志。</p>
<h4 id="6-开始挖矿"><a href="#6-开始挖矿" class="headerlink" title="6.开始挖矿"></a>6.开始挖矿</h4><p>在console下执行<code>miner.start()</code></p>
<p><strong><em>命令总结</em></strong></p>
<ol>
<li>创建私有链geth –datadir “./“ init “./genesis.json”</li>
<li>进入私有链geth –datadir “./“ console</li>
<li>创建账户personal.newAccount(“password”)</li>
<li>查账户余额，在geth命令行中键入：<code>my=eth.accounts[0]   eth.getBalance(my)</code></li>
<li>开始和停止挖矿miner.start()  miner.stop()</li>
<li>解锁账户personal.unlockAccount(my)</li>
<li>转账：eth.sendTransaction({from:my, to:other, value:10000})//转账之前要先解锁</li>
<li>挖矿后eth.blockNumber都会发现块在不停的增高。</li>
</ol>
<p><strong><em>参考链接</em></strong></p>
<p><a href="https://blog.csdn.net/niekai01/article/details/65679843" target="_blank" rel="noopener">https://blog.csdn.net/niekai01/article/details/65679843</a><br><a href="https://blog.csdn.net/sportshark/article/details/51855007" target="_blank" rel="noopener">https://blog.csdn.net/sportshark/article/details/51855007</a><br><a href="https://blog.csdn.net/wo541075754/article/details/79260040//miner.start()返回null的问题" target="_blank" rel="noopener">https://blog.csdn.net/wo541075754/article/details/79260040//miner.start()返回null的问题</a></p>
<p>关于私有链的问题：<a href="https://blog.csdn.net/weixin_40401264/article/details/78095222" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40401264/article/details/78095222</a></p>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/2018/05/17/按需加载和预加载/">按需加载和预加载</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-05-17</time><div class="content"><h2 id="按需加载和预加载"><a href="#按需加载和预加载" class="headerlink" title="按需加载和预加载"></a>按需加载和预加载</h2><p><strong>懒加载和预加载都是提高页面性能有效的办法，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</strong></p>
<h3 id="一、按需加载"><a href="#一、按需加载" class="headerlink" title="一、按需加载"></a>一、按需加载</h3><p>定义： 通过一些用户行为或者定时任务去触发一些加载动作。比如但不限于以下几个情况：鼠标点击、输入文字、拉动滚动条，鼠标移动、窗口大小更改等。加载的文件，可以是JS、图片  、CSS、HTML等。这个就是按需加载。</p>
<h4 id="按需加载HTML"><a href="#按需加载HTML" class="headerlink" title="按需加载HTML"></a>按需加载HTML</h4><ol>
<li>多页面结构就是按需加载的，目前针对单页面分析</li>
<li>页面一开始不解析HTML，根据需要来解析HTML。 解析HTML都是需要一定时间，特别是HTML中包含有img标签、引用了背景图片时，如果一开始就解析，那么势必会增加请求数。常见的有对话框、拉菜单、多标签的内容展示等，这些一开始是不需要解析，可以按需解析</li>
<li>实现方式</li>
</ol>
<pre><code>
&lt;script type=&quot;text/x-template&quot; id=&quot;suc_subscription&quot;&gt;
    &lt;!--假设这里的样式box-dytz 引用了一张背景图---&gt;
    &lt;div&gt;
    &lt;!--这里暂且用这张图片作为测试，实际中，大家可以替换为任何图片--&gt;
    &lt;img src=&quot;http://tid.tenpay.com/wp-content/uploads/2012/12/按需加载.jpg&quot; /&gt;
    &lt;/div&gt;
&lt;/script&gt;

</code></pre><h4 id="图片的按需加载"><a href="#图片的按需加载" class="headerlink" title="图片的按需加载"></a>图片的按需加载</h4><ol>
<li>按需加载图片，就是让图片默认开始不加载，而且在接近可视区域范围时，再进行加载。也称之为懒惰加载。</li>
<li>实现原理。它的触发动作是：当滚动条拉动到某个位置时，即将进入可视范围的图片需要加载。</li>
<li>实现步骤<ul>
<li>生成&lt;img data-src=”<a href="http://tid.tenpay.com/”url”&gt;标签时，用data-src来保存图片地址；" target="_blank" rel="noopener">http://tid.tenpay.com/”url”&gt;标签时，用data-src来保存图片地址；</a></li>
<li>记录的图片data-src都保存到数组里；</li>
<li>对滚动条进行事件绑定,假设绑定的函数为function lazyload(){};</li>
<li>在函数lazyload中，按照下面思路实现：计算图片的Y坐标，并计算可视区域的高度height，当Y小于等于(height+ scrollTop)时，图片的src的值用data-src的来替换，从而来实现图片的按需加载；<h4 id="按需执行JS"><a href="#按需执行JS" class="headerlink" title="按需执行JS"></a>按需执行JS</h4></li>
</ul>
</li>
<li>当某个动作触发后，再执行相应的JS，以便来渲染界面。</li>
<li>可以应用在下列场景：执行一些耗时比较久的JS代码，或执行JS后，需要加载比较多图片、加载iframe、加载广告等。</li>
<li>实现思路：<ul>
<li>对滚动条进行事件绑定,假设绑定的函数为function lazyLoadJS(){};</li>
<li>在函数lazyLoadJS中，按照下面思路实现：选择一个元素作为参照物，当滚动条即将靠近时该元素位置，开始执行加载对应JS；</li>
<li>在JS加载完毕后，开始执行相应的函数来渲染界面；</li>
<li>在实际项目中，可以根据需要设置一个目标距离，比如还有200像素该元素即将进入可视区域；按需加载JS和按需执行JS比较类似，这里就不再单独提供示例代码了；大家可以在按需执行JS的中示例中，把loadAD函数更改为动态加载JS即可；<h4 id="分屏展示"><a href="#分屏展示" class="headerlink" title="分屏展示"></a>分屏展示</h4></li>
</ul>
</li>
<li>当一个网页比较长，有好几个屏幕，而且加载了大量的图片、广告等资源文件时，分屏展示，可提升页面性能和用户体验。其实分屏展示也可以从按需加载的的角度来看待，默认是加载第一屏幕的内容，当滚动条拉动即将到达下一个屏幕时，再开始渲染下个屏的内容。换言之，是把图片、背景图片、HTML一起按需加载，一开始不对HTML进行解析，那么背景图、img图片也不会进行加载。</li>
<li>实现思路<ul>
<li>根据具体业务情况，收集主流最大的分辨率的高度；假设这里是用960px;</li>
<li>按照这个高度进行分屏，依次把下一个屏幕内的HTML用<code>&lt;textarea&gt;HTML&lt;/textarea&gt;</code> 来表示；</li>
<li>为了让页面的高度不变，需要让textarea占据一定的页面空间，也就是让页面出现对应的滚动条；因此需要指定样式visility:hidden，并指定它的高度和宽度。</li>
<li>利用上述讲的按需执行JS，把<code>&lt;textarea&gt;HTML&lt;/textarea&gt;</code>里面的HTML代码提取出来，重新填充到textarea的父节点上，便可实现解析对应HTML，从而实现分屏展示。</li>
</ul>
<hr>
<h3 id="二、预加载"><a href="#二、预加载" class="headerlink" title="二、预加载"></a>二、预加载</h3>在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。<h4 id="使用CSS和JS实现预加载"><a href="#使用CSS和JS实现预加载" class="headerlink" title="使用CSS和JS实现预加载"></a>使用CSS和JS实现预加载</h4></li>
<li>其实单纯使用CSS，就可预加载图片： #preload-01 { background: url(<a href="http://qiniu.cllgeek.com/react02.png" target="_blank" rel="noopener">http://qiniu.cllgeek.com/react02.png</a>) no-repeat -9999px -9999px; }  通过CSS的background属性将图片预加载到屏幕外的背景上。只要这些图片的路径保持不变，当它在Web页面的其他地方被调用时，浏览器就会在渲染过程中使用预加载（缓存）的图片。简单、高效，不需要任何JavaScript。</li>
<li>但是 使用该法加载的图片会同页面的其他内容一起加载，增加了页面的整体加载时间。为了解决这个问题，我们增加了一些JavaScript代码，来推迟预加载的时间，直到页面加载完毕。</li>
<li>例如<pre><code>//获取使用类选择器的元素，并为其设置了background属性，以预加载不同的图片。
function preloader() {
 if (document.getElementById) {
     document.getElementById(&quot;preload-01&quot;).style.background = &quot;url(http://qiniu.cllgeek.com/react02.png) no-repeat -9999px -9999px&quot;; document.getElementById(&quot;preload-02&quot;).style.background = &quot;url(http://qiniu.cllgeek.com/react03.png) no-repeat -9999px -9999px&quot;; document.getElementById(&quot;preload-03&quot;).style.background = &quot;url(http://qiniu.cllgeek.com/react04.png) no-repeat -9999px -9999px&quot;;
 }
}
//使用addLoadEvent()函数来延迟preloader()函数的加载时间，直到页面加载完毕。
function addLoadEvent(func) {
 var oldonload = window.onload;
 if (typeof window.onload != &#39;function&#39;) {
     window.onload = func;
 } else {
     window.onload = function() {
         if (oldonload) { oldonload(); }
         func();
     }
 }
}
addLoadEvent(preloader);
</code></pre><h4 id="仅使用js实现预加载，使用Image对象"><a href="#仅使用js实现预加载，使用Image对象" class="headerlink" title="仅使用js实现预加载，使用Image对象"></a>仅使用js实现预加载，使用Image对象</h4></li>
<li>只需简单编辑、加载所需要图片的路径与名称即可。 该方法尤其适用预加载大量的图片。我的博物馆网站使用该技术，预加载图片数量达50多张。将该脚本应用到登录页面，只要用户输入登录帐号，大部分画廊图片将被预加载。</li>
<li>例子：<pre><code>&lt;div class=&quot;hidden&quot;&gt;
 &lt;script type=&quot;text/javascript&quot;&gt;  
     &lt;!--//--&gt;&lt;![CDATA[//&gt;&lt;!--  
         var images = new Array()  
         function preload() {  
             for (i = 0; i &lt; preload.arguments.length; i++) {  
                 images[i] = new Image()  
                 images[i].src = preload.arguments[i]  
             }  
         }  
         preload(
             &quot;http://qiniu.cllgeek.com/react02.png&quot;,
             &quot;http://qiniu.cllgeek.com/react03.png&quot;,
             &quot;http://qiniu.cllgeek.com/react04.png&quot;
         )
     //--&gt;&lt;!]]&gt;  
 &lt;/script&gt;
&lt;/div&gt;
</code></pre><h4 id="使用ajax实现预加载"><a href="#使用ajax实现预加载" class="headerlink" title="使用ajax实现预加载"></a>使用ajax实现预加载</h4></li>
<li>该方法利用DOM，不仅仅预加载图片，还会预加载CSS、JavaScript等相关的东西。使用Ajax，比直接使用JavaScript，优越之处在于预加载不会影响到当前页面。</li>
<li>例子<pre><code>window.onload = function(){
 setTimeout(function(){
     //xhr to request js and css
     var xhr = new XMLHttpRequest()
     xhr.open(&#39;GET&#39;,&#39;http://geekj.com/preload.js&#39;)
     xhr.send()
     xhr = new XMLHttpRequest()
     xhr.open(&#39;GET&#39;, &#39;http://geekjc.com/preload.css&#39;);
     xhr.send(&#39;&#39;);
     // preload image  
     new Image().src = &quot;http://geekjc.com/preload.png&quot;;
 },1000)  //1000毫秒的超时是为了防止脚本挂起，而导致正常页面出现功能问题。
}
</code></pre><h4 id="使用PreloadJS库"><a href="#使用PreloadJS库" class="headerlink" title="使用PreloadJS库"></a>使用PreloadJS库</h4>PreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供了对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。</li>
</ol>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="http://www.cnblogs.com/mamimi/p/7646358.html" target="_blank" rel="noopener">http://www.cnblogs.com/mamimi/p/7646358.html</a><br><a href="https://github.com/ljianshu/Blog/issues/8" target="_blank" rel="noopener">https://github.com/ljianshu/Blog/issues/8</a><br><a href="https://www.geekjc.com/post/58d94d0f16a3655650d6fafe" target="_blank" rel="noopener">https://www.geekjc.com/post/58d94d0f16a3655650d6fafe</a></p>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/2018/05/15/js引擎/">js引擎</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-05-15</time><div class="content"><p>JavaScript引擎是一个专门处理JavaScript脚本的程序虚拟机，一般会附带在网页浏览器之中。</p>
<p>例如</p>
<p> v8，用c++编写，Google Chrome一部分，也用于node.js</p>
<p>JavaScriptCore ，用于webkit型浏览器，如Safari</p>
<p>spidermonkey，第一款JavaScript引擎，用于如Firefox</p>
<p>chakra(Jscript引擎），用于IE11</p>
<p>chakra(JavaScript引擎），用于Microsoft Edge</p>
<h3 id="1-基本工作"><a href="#1-基本工作" class="headerlink" title="1.基本工作"></a>1.基本工作</h3><p>把开发人员写的 JavaScript 代码转换成高效、优化的代码，这样就可以通过浏览器进行解释甚至嵌入到应用中。很难界定JavaScript引擎是编译器还是解释器。因为像V8引擎，为了提高JS的运行性能，在运行之前会将js编译为本地的机器码，然后再去执行机器码。</p>
<h3 id="2-组成："><a href="#2-组成：" class="headerlink" title="2.组成："></a>2.组成：</h3><p>-编译器。主要工作是将源代码编译成抽象语法树，然后在某些引擎中还包含将抽象语法树转换成字节码。</p>
<p>-解释器。在某些引擎中，解释器主要是接受字节码，解释执行这个字节码，然后也依赖来及回收机制等。</p>
<p>-JIT工具。一个能够JIT的工具，将字节码或者抽象语法树转换成本地代码，当然它也需要依赖牢记</p>
<p>-垃圾回收器和分析工具（profiler）。它们负责垃圾回收和收集引擎中的信息，帮助改善引擎的性能和功效。</p>
<h3 id="3-工作原理"><a href="#3-工作原理" class="headerlink" title="3.工作原理"></a>3.工作原理</h3><p>-JavaScriptCore：</p>
<p>  源代码-&gt;抽象语法树-&gt;字节码</p>
<p>  通过词法分析器将源代码构建为抽象语法树，解析器生成字节码，4个JIM进程分析和执行字节码。</p>
<p>-v8：</p>
<p>  源代码-&gt;抽象语法树-&gt;本地码<br>  v8引擎并不将抽象语法树转化为字节码或其他中间表示，是为了减少这部分的时间，这部分在网页加载的时候完成，虽然可以提高优化的可能，但是带来巨大的时间浪费。</p>
<h3 id="4-JavaScript引擎和ECMAscript的关系："><a href="#4-JavaScript引擎和ECMAscript的关系：" class="headerlink" title="4.JavaScript引擎和ECMAscript的关系："></a>4.JavaScript引擎和ECMAscript的关系：</h3><p><strong>前者根据后者定义的规则来解析js代码</strong></p>
<h3 id="5-JavaScript引擎和浏览器的关系"><a href="#5-JavaScript引擎和浏览器的关系" class="headerlink" title="5.JavaScript引擎和浏览器的关系"></a>5.JavaScript引擎和浏览器的关系</h3><p>JavaScript引擎是浏览器的组成部分之一，不同的浏览器采用了不同的JavaScript引擎。</p>
<p>对于网页的工作来说，需要两个引擎。渲染引擎和JavaScript引擎。 渲染引擎负责网页的渲染；JavaScript引擎负责JavaScript代码执行。</p>
<p>JavaScript引擎提供调用接口被渲染引擎使用，渲染引擎使用的JavaScript引擎来处理js代码并获得结果。此外，JavaScript引擎需要渲染引擎提供桥接的接口以便能够访问渲染引擎构建的DOM树，操作DOM。js引擎和渲染引擎 属于互相调用的关系</p>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/2018/03/08/hexo的第一天/">hexo 的第一天</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-03-08</time><div class="content"><p>从大二开始作为一个<strong>伪前端</strong>，断断续续写了三年多的代码了，从csdn上转到个人博客，打算支摊好好干啦yep! &gt;M&lt;</p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By cici</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.4.3"></script><script src="/js/fancybox.js?version=1.4.3"></script><script src="/js/sidebar.js?version=1.4.3"></script><script src="/js/copy.js?version=1.4.3"></script><script src="/js/fireworks.js?version=1.4.3"></script><script src="/js/transition.js?version=1.4.3"></script><script src="/js/scroll.js?version=1.4.3"></script><script src="/js/head.js?version=1.4.3"></script></body></html>