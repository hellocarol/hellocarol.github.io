<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="按需加载和预加载"><meta name="keywords" content="计算机基础 安全"><meta name="author" content="cici,undefined"><meta name="copyright" content="cici"><title>按需加载和预加载 | hellocici</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.4.3"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  localSearch: undefined
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#按需加载和预加载"><span class="toc-number">1.</span> <span class="toc-text">按需加载和预加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、按需加载"><span class="toc-number">1.1.</span> <span class="toc-text">一、按需加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#按需加载HTML"><span class="toc-number">1.1.1.</span> <span class="toc-text">按需加载HTML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图片的按需加载"><span class="toc-number">1.1.2.</span> <span class="toc-text">图片的按需加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#按需执行JS"><span class="toc-number">1.1.3.</span> <span class="toc-text">按需执行JS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分屏展示"><span class="toc-number">1.1.4.</span> <span class="toc-text">分屏展示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、预加载"><span class="toc-number">1.2.</span> <span class="toc-text">二、预加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用CSS和JS实现预加载"><span class="toc-number">1.2.1.</span> <span class="toc-text">使用CSS和JS实现预加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#仅使用js实现预加载，使用Image对象"><span class="toc-number">1.2.2.</span> <span class="toc-text">仅使用js实现预加载，使用Image对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用ajax实现预加载"><span class="toc-number">1.2.3.</span> <span class="toc-text">使用ajax实现预加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用PreloadJS库"><span class="toc-number">1.2.4.</span> <span class="toc-text">使用PreloadJS库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考链接"><span class="toc-number">1.2.5.</span> <span class="toc-text">参考链接</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">cici</div><div class="author-info__description text-center">node js koa vue react springmvc mongodb mysql jquery bootstrap</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">5</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container" style="background-image: url(true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">hellocici</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">按需加载和预加载</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-05-17</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/计算机基础-安全/">计算机基础 安全</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h2 id="按需加载和预加载"><a href="#按需加载和预加载" class="headerlink" title="按需加载和预加载"></a>按需加载和预加载</h2><p><strong>懒加载和预加载都是提高页面性能有效的办法，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</strong></p>
<h3 id="一、按需加载"><a href="#一、按需加载" class="headerlink" title="一、按需加载"></a>一、按需加载</h3><p>定义： 通过一些用户行为或者定时任务去触发一些加载动作。比如但不限于以下几个情况：鼠标点击、输入文字、拉动滚动条，鼠标移动、窗口大小更改等。加载的文件，可以是JS、图片  、CSS、HTML等。这个就是按需加载。</p>
<h4 id="按需加载HTML"><a href="#按需加载HTML" class="headerlink" title="按需加载HTML"></a>按需加载HTML</h4><ol>
<li>多页面结构就是按需加载的，目前针对单页面分析</li>
<li>页面一开始不解析HTML，根据需要来解析HTML。 解析HTML都是需要一定时间，特别是HTML中包含有img标签、引用了背景图片时，如果一开始就解析，那么势必会增加请求数。常见的有对话框、拉菜单、多标签的内容展示等，这些一开始是不需要解析，可以按需解析</li>
<li>实现方式</li>
</ol>
<pre><code>
&lt;script type=&quot;text/x-template&quot; id=&quot;suc_subscription&quot;&gt;
    &lt;!--假设这里的样式box-dytz 引用了一张背景图---&gt;
    &lt;div&gt;
    &lt;!--这里暂且用这张图片作为测试，实际中，大家可以替换为任何图片--&gt;
    &lt;img src=&quot;http://tid.tenpay.com/wp-content/uploads/2012/12/按需加载.jpg&quot; /&gt;
    &lt;/div&gt;
&lt;/script&gt;

</code></pre><h4 id="图片的按需加载"><a href="#图片的按需加载" class="headerlink" title="图片的按需加载"></a>图片的按需加载</h4><ol>
<li>按需加载图片，就是让图片默认开始不加载，而且在接近可视区域范围时，再进行加载。也称之为懒惰加载。</li>
<li>实现原理。它的触发动作是：当滚动条拉动到某个位置时，即将进入可视范围的图片需要加载。</li>
<li>实现步骤<ul>
<li>生成&lt;img data-src=”<a href="http://tid.tenpay.com/”url”&gt;标签时，用data-src来保存图片地址；" target="_blank" rel="noopener">http://tid.tenpay.com/”url”&gt;标签时，用data-src来保存图片地址；</a></li>
<li>记录的图片data-src都保存到数组里；</li>
<li>对滚动条进行事件绑定,假设绑定的函数为function lazyload(){};</li>
<li>在函数lazyload中，按照下面思路实现：计算图片的Y坐标，并计算可视区域的高度height，当Y小于等于(height+ scrollTop)时，图片的src的值用data-src的来替换，从而来实现图片的按需加载；<h4 id="按需执行JS"><a href="#按需执行JS" class="headerlink" title="按需执行JS"></a>按需执行JS</h4></li>
</ul>
</li>
<li>当某个动作触发后，再执行相应的JS，以便来渲染界面。</li>
<li>可以应用在下列场景：执行一些耗时比较久的JS代码，或执行JS后，需要加载比较多图片、加载iframe、加载广告等。</li>
<li>实现思路：<ul>
<li>对滚动条进行事件绑定,假设绑定的函数为function lazyLoadJS(){};</li>
<li>在函数lazyLoadJS中，按照下面思路实现：选择一个元素作为参照物，当滚动条即将靠近时该元素位置，开始执行加载对应JS；</li>
<li>在JS加载完毕后，开始执行相应的函数来渲染界面；</li>
<li>在实际项目中，可以根据需要设置一个目标距离，比如还有200像素该元素即将进入可视区域；按需加载JS和按需执行JS比较类似，这里就不再单独提供示例代码了；大家可以在按需执行JS的中示例中，把loadAD函数更改为动态加载JS即可；<h4 id="分屏展示"><a href="#分屏展示" class="headerlink" title="分屏展示"></a>分屏展示</h4></li>
</ul>
</li>
<li>当一个网页比较长，有好几个屏幕，而且加载了大量的图片、广告等资源文件时，分屏展示，可提升页面性能和用户体验。其实分屏展示也可以从按需加载的的角度来看待，默认是加载第一屏幕的内容，当滚动条拉动即将到达下一个屏幕时，再开始渲染下个屏的内容。换言之，是把图片、背景图片、HTML一起按需加载，一开始不对HTML进行解析，那么背景图、img图片也不会进行加载。</li>
<li>实现思路<ul>
<li>根据具体业务情况，收集主流最大的分辨率的高度；假设这里是用960px;</li>
<li>按照这个高度进行分屏，依次把下一个屏幕内的HTML用<code>&lt;textarea&gt;HTML&lt;/textarea&gt;</code> 来表示；</li>
<li>为了让页面的高度不变，需要让textarea占据一定的页面空间，也就是让页面出现对应的滚动条；因此需要指定样式visility:hidden，并指定它的高度和宽度。</li>
<li>利用上述讲的按需执行JS，把<code>&lt;textarea&gt;HTML&lt;/textarea&gt;</code>里面的HTML代码提取出来，重新填充到textarea的父节点上，便可实现解析对应HTML，从而实现分屏展示。</li>
</ul>
<hr>
<h3 id="二、预加载"><a href="#二、预加载" class="headerlink" title="二、预加载"></a>二、预加载</h3>在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。<h4 id="使用CSS和JS实现预加载"><a href="#使用CSS和JS实现预加载" class="headerlink" title="使用CSS和JS实现预加载"></a>使用CSS和JS实现预加载</h4></li>
<li>其实单纯使用CSS，就可预加载图片： #preload-01 { background: url(<a href="http://qiniu.cllgeek.com/react02.png" target="_blank" rel="noopener">http://qiniu.cllgeek.com/react02.png</a>) no-repeat -9999px -9999px; }  通过CSS的background属性将图片预加载到屏幕外的背景上。只要这些图片的路径保持不变，当它在Web页面的其他地方被调用时，浏览器就会在渲染过程中使用预加载（缓存）的图片。简单、高效，不需要任何JavaScript。</li>
<li>但是 使用该法加载的图片会同页面的其他内容一起加载，增加了页面的整体加载时间。为了解决这个问题，我们增加了一些JavaScript代码，来推迟预加载的时间，直到页面加载完毕。</li>
<li>例如<pre><code>//获取使用类选择器的元素，并为其设置了background属性，以预加载不同的图片。
function preloader() {
 if (document.getElementById) {
     document.getElementById(&quot;preload-01&quot;).style.background = &quot;url(http://qiniu.cllgeek.com/react02.png) no-repeat -9999px -9999px&quot;; document.getElementById(&quot;preload-02&quot;).style.background = &quot;url(http://qiniu.cllgeek.com/react03.png) no-repeat -9999px -9999px&quot;; document.getElementById(&quot;preload-03&quot;).style.background = &quot;url(http://qiniu.cllgeek.com/react04.png) no-repeat -9999px -9999px&quot;;
 }
}
//使用addLoadEvent()函数来延迟preloader()函数的加载时间，直到页面加载完毕。
function addLoadEvent(func) {
 var oldonload = window.onload;
 if (typeof window.onload != &#39;function&#39;) {
     window.onload = func;
 } else {
     window.onload = function() {
         if (oldonload) { oldonload(); }
         func();
     }
 }
}
addLoadEvent(preloader);
</code></pre><h4 id="仅使用js实现预加载，使用Image对象"><a href="#仅使用js实现预加载，使用Image对象" class="headerlink" title="仅使用js实现预加载，使用Image对象"></a>仅使用js实现预加载，使用Image对象</h4></li>
<li>只需简单编辑、加载所需要图片的路径与名称即可。 该方法尤其适用预加载大量的图片。我的博物馆网站使用该技术，预加载图片数量达50多张。将该脚本应用到登录页面，只要用户输入登录帐号，大部分画廊图片将被预加载。</li>
<li>例子：<pre><code>&lt;div class=&quot;hidden&quot;&gt;
 &lt;script type=&quot;text/javascript&quot;&gt;  
     &lt;!--//--&gt;&lt;![CDATA[//&gt;&lt;!--  
         var images = new Array()  
         function preload() {  
             for (i = 0; i &lt; preload.arguments.length; i++) {  
                 images[i] = new Image()  
                 images[i].src = preload.arguments[i]  
             }  
         }  
         preload(
             &quot;http://qiniu.cllgeek.com/react02.png&quot;,
             &quot;http://qiniu.cllgeek.com/react03.png&quot;,
             &quot;http://qiniu.cllgeek.com/react04.png&quot;
         )
     //--&gt;&lt;!]]&gt;  
 &lt;/script&gt;
&lt;/div&gt;
</code></pre><h4 id="使用ajax实现预加载"><a href="#使用ajax实现预加载" class="headerlink" title="使用ajax实现预加载"></a>使用ajax实现预加载</h4></li>
<li>该方法利用DOM，不仅仅预加载图片，还会预加载CSS、JavaScript等相关的东西。使用Ajax，比直接使用JavaScript，优越之处在于预加载不会影响到当前页面。</li>
<li>例子<pre><code>window.onload = function(){
 setTimeout(function(){
     //xhr to request js and css
     var xhr = new XMLHttpRequest()
     xhr.open(&#39;GET&#39;,&#39;http://geekj.com/preload.js&#39;)
     xhr.send()
     xhr = new XMLHttpRequest()
     xhr.open(&#39;GET&#39;, &#39;http://geekjc.com/preload.css&#39;);
     xhr.send(&#39;&#39;);
     // preload image  
     new Image().src = &quot;http://geekjc.com/preload.png&quot;;
 },1000)  //1000毫秒的超时是为了防止脚本挂起，而导致正常页面出现功能问题。
}
</code></pre><h4 id="使用PreloadJS库"><a href="#使用PreloadJS库" class="headerlink" title="使用PreloadJS库"></a>使用PreloadJS库</h4>PreloadJS提供了一种预加载内容的一致方式，以便在HTML应用程序中使用。预加载可以使用HTML标签以及XHR来完成。默认情况下，PreloadJS会尝试使用XHR加载内容，因为它提供了对进度和完成事件的更好支持，但是由于跨域问题，使用基于标记的加载可能更好。</li>
</ol>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="http://www.cnblogs.com/mamimi/p/7646358.html" target="_blank" rel="noopener">http://www.cnblogs.com/mamimi/p/7646358.html</a><br><a href="https://github.com/ljianshu/Blog/issues/8" target="_blank" rel="noopener">https://github.com/ljianshu/Blog/issues/8</a><br><a href="https://www.geekjc.com/post/58d94d0f16a3655650d6fafe" target="_blank" rel="noopener">https://www.geekjc.com/post/58d94d0f16a3655650d6fafe</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">cici</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/05/17/按需加载和预加载/">http://yoursite.com/2018/05/17/按需加载和预加载/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/计算机基础-安全/">计算机基础 安全</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/25/ubuntu环境中使用geth搭建私有网络/"><i class="fa fa-chevron-left">  </i><span>ubuntu环境中使用geth搭建私有网络test</span></a></div><div class="next-post pull-right"><a href="/2018/05/15/js引擎/"><span>js引擎</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By cici</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.4.3"></script><script src="/js/fancybox.js?version=1.4.3"></script><script src="/js/sidebar.js?version=1.4.3"></script><script src="/js/copy.js?version=1.4.3"></script><script src="/js/fireworks.js?version=1.4.3"></script><script src="/js/transition.js?version=1.4.3"></script><script src="/js/scroll.js?version=1.4.3"></script><script src="/js/head.js?version=1.4.3"></script></body></html>